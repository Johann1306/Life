<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu de Snake en Vanille JS</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #222;
            font-family: Arial, sans-serif;
            color: #eee;
        }

        #game-area {
            background-color: #333;
            border: 4px solid #555;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        #score-board {
            margin-bottom: 20px;
            font-size: 1.5em;
            font-weight: bold;
            color: #0f0; /* Vert vif pour le score */
        }
    </style>
</head>
<body>

    <div id="score-board">Score: 0</div>
    <canvas id="game-area" width="400" height="400"></canvas>

    <script>
        // Récupération de l'élément canvas et de son contexte de dessin
        const canvas = document.getElementById('game-area');
        const ctx = canvas.getContext('2d');
        const scoreBoard = document.getElementById('score-board');

        // Configuration du jeu
        const gridSize = 20; // Taille d'un "carré" du serpent ou de la nourriture
        const tileCount = canvas.width / gridSize; // Nombre de carrés par côté (20x20)
        let snake = [{ x: 10, y: 10 }]; // Position initiale du serpent (au milieu)
        let food = {};
        let score = 0;
        let velocityX = 0;
        let velocityY = 0; // Direction initiale : arrêtée
        let nextVelocityX = 0;
        let nextVelocityY = 0; // Prochaine direction pour éviter le demi-tour instantané
        let gameLoopInterval;
        const gameSpeed = 150; // Vitesse du jeu en millisecondes (plus petit = plus rapide)

        // --- Fonctions du Jeu ---

        /**
         * Place la nourriture à un endroit aléatoire où le serpent n'est pas.
         */
        function placeFood() {
            do {
                food.x = Math.floor(Math.random() * tileCount);
                food.y = Math.floor(Math.random() * tileCount);
            } while (isSnakeCollision(food.x, food.y, true));
        }

        /**
         * Vérifie si les coordonnées données correspondent à un segment du serpent.
         * @param {number} x - Coordonnée X.
         * @param {number} y - Coordonnée Y.
         * @param {boolean} [checkHead=false] - Inclure la tête du serpent dans la vérification.
         * @returns {boolean}
         */
        function isSnakeCollision(x, y, checkHead = false) {
            for (let i = checkHead ? 0 : 1; i < snake.length; i++) {
                if (snake[i].x === x && snake[i].y === y) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Initialise ou réinitialise le jeu.
         */
        function resetGame() {
            snake = [{ x: 10, y: 10 }];
            score = 0;
            velocityX = 0;
            velocityY = 0;
            nextVelocityX = 0;
            nextVelocityY = 0;
            scoreBoard.textContent = `Score: 0`;
            placeFood();

            // S'assurer qu'un seul intervalle de jeu est actif
            if (gameLoopInterval) {
                clearInterval(gameLoopInterval);
            }
            gameLoopInterval = setInterval(gameLoop, gameSpeed);
        }

        /**
         * Boucle principale du jeu. Appelée périodiquement.
         */
        function gameLoop() {
            // Appliquer la prochaine direction
            velocityX = nextVelocityX;
            velocityY = nextVelocityY;

            // 1. Mouvement de la tête
            let headX = snake[0].x + velocityX;
            let headY = snake[0].y + velocityY;

            // 2. Vérification des collisions avec les murs
            if (headX < 0 || headX >= tileCount || headY < 0 || headY >= tileCount) {
                gameOver();
                return;
            }

            // 3. Vérification des auto-collisions (le serpent mord sa queue)
            if (isSnakeCollision(headX, headY, false)) {
                gameOver();
                return;
            }

            // 4. Insertion de la nouvelle tête
            let newHead = { x: headX, y: headY };
            snake.unshift(newHead); // Ajoute la nouvelle tête au début du tableau

            // 5. Vérification si la nourriture est mangée
            if (headX === food.x && headY === food.y) {
                score++;
                scoreBoard.textContent = `Score: ${score}`;
                placeFood(); // Placer la nouvelle nourriture
                // Le serpent ne rétrécit pas (ne pas retirer la queue)
            } else {
                snake.pop(); // Retirer l'ancienne queue (mouvement normal)
            }

            // 6. Dessin du jeu
            drawGame();
        }

        /**
         * Dessine l'état actuel du jeu sur le canvas.
         */
        function drawGame() {
            // Fond (efface l'image précédente)
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Dessin de la nourriture (Rouge)
            ctx.fillStyle = 'red';
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 1, gridSize - 1);

            // Dessin du serpent (Vert)
            ctx.fillStyle = '#0f0';
            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? '#0c0' : '#0f0'; // Tête légèrement différente
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 1, gridSize - 1);
            });
        }

        /**
         * Arrête le jeu et affiche le message "Game Over".
         */
        function gameOver() {
            clearInterval(gameLoopInterval);
            ctx.fillStyle = 'white';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2);
            ctx.font = '15px Arial';
            ctx.fillText(`Score final: ${score}`, canvas.width / 2, canvas.height / 2 + 30);
            ctx.fillText('Appuyez sur une flèche pour recommencer', canvas.width / 2, canvas.height / 2 + 55);
        }

        // --- Gestion des Entrées Utilisateur ---

        document.addEventListener('keydown', (e) => {
            let tempX = nextVelocityX;
            let tempY = nextVelocityY;

            // Déterminer la nouvelle direction
            switch (e.key) {
                case 'ArrowUp':
                case 'z':
                    if (velocityY !== 1) { tempX = 0; tempY = -1; }
                    break;
                case 'ArrowDown':
                case 's':
                    if (velocityY !== -1) { tempX = 0; tempY = 1; }
                    break;
                case 'ArrowLeft':
                case 'q':
                    if (velocityX !== 1) { tempX = -1; tempY = 0; }
                    break;
                case 'ArrowRight':
                case 'd':
                    if (velocityX !== -1) { tempX = 1; tempY = 0; }
                    break;
                default:
                    return; // Ignorer les autres touches
            }
            
            // Vérifier si le jeu a besoin d'être redémarré
            if (velocityX === 0 && velocityY === 0 && (tempX !== 0 || tempY !== 0)) {
                // Si le serpent est immobile (début ou fin de partie), on redémarre
                resetGame();
            }

            // Stocker la prochaine direction
            nextVelocityX = tempX;
            nextVelocityY = tempY;
        });

        // Initialisation de la première partie (pour placer la nourriture et dessiner le fond)
        resetGame();
        clearInterval(gameLoopInterval); // Arrêter l'intervalle après l'initialisation pour attendre le mouvement initial
        drawGame(); // Dessiner l'état initial
    </script>
</body>
</html>