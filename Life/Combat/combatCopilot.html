<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Combat 2 joueurs - Canvas</title>
    <style>
        :root {
            --bg: #111;
            --ground: #2b2b2b;
            --ui: #ddd
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--ui);
            font-family: system-ui, Segoe UI, Roboto, Arial
        }

        #gameWrap {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%
        }

        canvas {
            background: linear-gradient(#0b1220, #0b1220 70%, #071018 100%);
            border: 4px solid #222;
            box-shadow: 0 8px 30px rgba(0, 0, 0, .7)
        }

        .hint {
            position: fixed;
            left: 12px;
            bottom: 12px;
            color: #bbb;
            font-size: 13px
        }
    </style>
</head>

<body>
    <div id="gameWrap">
        <canvas id="c" width="900" height="420"></canvas>
    </div>
    <div class="hint">R pour redémarrer • Joueur Rouge: Z Q D + Espace • Joueur Bleu: ↑ ← → + Entrée</div>

    <script>
        /* --- Configuration --- */
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        const GROUND_Y = H - 60;
        const GRAVITY = 0.6;
        const FRICTION = 0.85;

        /* --- Utilitaires clavier (support AZERTY/QWERTY) --- */
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            keys[e.code] = true;
            // prevent scrolling on space/arrow keys
            if ([" ", "Spacebar", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key) || e.code === "Space") {
                e.preventDefault();
            }
        });
        window.addEventListener('keyup', e => {
            keys[e.key] = false;
            keys[e.code] = false;
        });

        /* --- Joueur prototype --- */
        class Player {
            constructor(x, y, color, controls) {
                this.x = x; this.y = y;
                this.w = 36; this.h = 56;
                this.vx = 0; this.vy = 0;
                this.color = color;
                this.hp = 100;
                this.onGround = false;
                this.facing = 1; // 1 = right, -1 = left
                this.attackCooldown = 0;
                this.controls = controls; // object with keys
                this.isAttacking = false;
            }

            reset(x, y) {
                this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.hp = 100; this.onGround = false; this.attackCooldown = 0; this.isAttacking = false;
            }

            update() {
                // Horizontal movement
                let moveLeft = isKeyPressed(this.controls.left);
                let moveRight = isKeyPressed(this.controls.right);
                if (moveLeft && !moveRight) { this.vx = Math.max(this.vx - 1.2, -6); this.facing = -1; }
                else if (moveRight && !moveLeft) { this.vx = Math.min(this.vx + 1.2, 6); this.facing = 1; }
                else { this.vx *= 0.85; if (Math.abs(this.vx) < 0.1) this.vx = 0; }

                // Jump (controlled jump)
                if (isKeyPressedOnce(this.controls.jump) && this.onGround) {
                    this.vy = -12.5;
                    this.onGround = false;
                }
                // Short hop if release early
                if (isKeyReleasedOnce(this.controls.jump) && this.vy < -4) {
                    this.vy = -4;
                }

                // Gravity
                this.vy += GRAVITY;

                // Apply velocities
                this.x += this.vx;
                this.y += this.vy;

                // Ground collision
                if (this.y + this.h > GROUND_Y) {
                    this.y = GROUND_Y - this.h;
                    this.vy = 0;
                    this.onGround = true;
                } else {
                    this.onGround = false;
                }

                // Canvas bounds
                if (this.x < 0) { this.x = 0; this.vx = 0; }
                if (this.x + this.w > W) { this.x = W - this.w; this.vx = 0; }

                // Attack cooldown decrement
                if (this.attackCooldown > 0) this.attackCooldown -= 16;
                if (this.attackCooldown < 0) this.attackCooldown = 0;
            }

            draw() {
                // Body (rectangle)
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.w, this.h);
                // Head (small square)
                ctx.fillStyle = shade(this.color, -20);
                ctx.fillRect(this.x + this.w / 4, this.y - 12, this.w / 2, 12);
                // Simple eyes for personality
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x + (this.facing === 1 ? this.w * 0.6 : this.w * 0.2), this.y - 10, 4, 4);
            }

            attackHitbox() {
                // short punch in front
                const range = 28;
                if (this.facing === 1) {
                    return { x: this.x + this.w, y: this.y + 10, w: range, h: this.h - 20 };
                } else {
                    return { x: this.x - range, y: this.y + 10, w: range, h: this.h - 20 };
                }
            }
        }

        /* --- Helpers for key handling with "once" detection --- */
        const keyState = {}; // track previous state for once/release detection
        function isKeyPressed(keyNames) {
            if (!Array.isArray(keyNames)) keyNames = [keyNames];
            return keyNames.some(k => !!keys[k]);
        }
        function isKeyPressedOnce(keyNames) {
            if (!Array.isArray(keyNames)) keyNames = [keyNames];
            for (let k of keyNames) {
                if (!!keys[k] && !keyState[k]) { keyState[k] = true; return true; }
            }
            return false;
        }
        function isKeyReleasedOnce(keyNames) {
            if (!Array.isArray(keyNames)) keyNames = [keyNames];
            for (let k of keyNames) {
                if (!keys[k] && keyState[k]) { keyState[k] = false; return true; }
            }
            return false;
        }

        /* --- Create players --- */
        /* Controls: provide multiple key options for AZERTY/QWERTY robustness */
        const p1Controls = {
            left: ['q', 'KeyQ', 'a', 'KeyA'],   // Q (AZERTY) and A (QWERTY)
            right: ['d', 'KeyD'],
            jump: ['z', 'KeyZ', 'w', 'KeyW'],   // Z (AZERTY) and W (QWERTY)
            attack: [' ', 'Space', 'Spacebar'] // Space
        };
        const p2Controls = {
            left: ['ArrowLeft'],
            right: ['ArrowRight'],
            jump: ['ArrowUp'],
            attack: ['Enter']
        };

        const p1 = new Player(120, GROUND_Y - 56, '#ff4d4d', p1Controls);
        const p2 = new Player(W - 160, GROUND_Y - 56, '#4da6ff', p2Controls);

        /* --- Game state --- */
        let running = true;
        let winner = null;
        let lastTime = performance.now();

        /* --- Main loop --- */
        function loop(now) {
            const dt = now - lastTime;
            lastTime = now;
            update(dt);
            render();
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        /* --- Update logic --- */
        function update(dt) {
            if (!running) return;

            // Update players
            p1.update();
            p2.update();

            // Attacks: trigger on keydown once and if cooldown allows
            handleAttack(p1, p2);
            handleAttack(p2, p1);

            // Check death
            if (p1.hp <= 0 || p2.hp <= 0) {
                running = false;
                winner = p1.hp <= 0 ? 'Bleu' : 'Rouge';
            }
        }

        /* --- Attack handling --- */
        function handleAttack(attacker, defender) {
            // detect attack key pressed once
            if (isKeyPressedOnce(attacker.controls.attack) && attacker.attackCooldown === 0) {
                attacker.attackCooldown = 400; // ms
                attacker.isAttacking = true;
                // brief attack animation: small forward push
                attacker.vx += attacker.facing * 2.5;
                // Check collision with defender
                const aHit = attacker.attackHitbox();
                const dBox = { x: defender.x, y: defender.y, w: defender.w, h: defender.h };
                if (rectIntersect(aHit, dBox)) {
                    // Apply damage and knockback
                    defender.hp = Math.max(0, defender.hp - 10);
                    defender.vx += attacker.facing * 6; // knockback horizontal
                    defender.vy = -6; // slight vertical knockback
                    // small visual feedback: flash (we'll draw in render)
                    defender._flash = 12;
                }
                // reset attack flag after short time
                setTimeout(() => attacker.isAttacking = false, 120);
            }
        }

        /* --- Collision helper --- */
        function rectIntersect(a, b) {
            return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
        }

        /* --- Rendering --- */
        function render() {
            // clear
            ctx.clearRect(0, 0, W, H);

            // ground
            ctx.fillStyle = '#0b6b3a';
            ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
            // platform line
            ctx.fillStyle = '#0a5a31';
            ctx.fillRect(0, GROUND_Y - 6, W, 6);

            // draw players (with flash if hit)
            drawPlayerWithFlash(p1);
            drawPlayerWithFlash(p2);

            // draw attack hitboxes (optional subtle)
            if (p1.isAttacking) drawHitbox(p1.attackHitbox(), 'rgba(255,80,80,0.12)');
            if (p2.isAttacking) drawHitbox(p2.attackHitbox(), 'rgba(80,160,255,0.12)');

            // UI: health bars
            drawHealthBar(20, 18, 360, 18, p1.hp, '#ff4d4d', 'Rouge');
            drawHealthBar(W - 380, 18, 360, 18, p2.hp, '#4da6ff', 'Bleu');

            // names
            ctx.fillStyle = '#bbb';
            ctx.font = '13px system-ui';
            ctx.fillText('Joueur 1 (Rouge)', 24, 16);
            ctx.fillText('Joueur 2 (Bleu)', W - 120, 16);

            // winner overlay
            if (!running && winner) {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(0, 0, W, H);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 44px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText('Gagnant : ' + winner, W / 2, H / 2 - 10);
                ctx.font = '18px system-ui';
                ctx.fillText('Appuyez sur R pour rejouer', W / 2, H / 2 + 30);
                ctx.textAlign = 'start';
            }

            // debug (optional)
            // ctx.fillStyle='#888'; ctx.fillText('FPS: ' + Math.round(1000/(performance.now()-lastTime||16)), 10, H-10);
        }

        function drawPlayerWithFlash(p) {
            if (p._flash && p._flash > 0) {
                ctx.globalAlpha = 0.6 + 0.4 * Math.random();
                p._flash -= 1;
            }
            p.draw();
            ctx.globalAlpha = 1;
        }

        function drawHitbox(hb, color) {
            ctx.fillStyle = color;
            ctx.fillRect(hb.x, hb.y, hb.w, hb.h);
        }

        function drawHealthBar(x, y, w, h, val, color, label) {
            // background
            ctx.fillStyle = '#333';
            roundRect(ctx, x, y, w, h, 6, true, false);
            // fill
            const pct = Math.max(0, Math.min(1, val / 100));
            ctx.fillStyle = color;
            roundRect(ctx, x + 2, y + 2, (w - 4) * pct, h - 4, 5, true, false);
            // border
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            roundRect(ctx, x, y, w, h, 6, false, true);
            // text
            ctx.fillStyle = '#fff';
            ctx.font = '13px system-ui';
            ctx.fillText(label + ' : ' + Math.round(val), x + w / 2 - 30, y + h - 4);
        }

        /* --- Utilities --- */
        function roundRect(ctx, x, y, w, h, r, fill, stroke) {
            if (typeof r === 'undefined') r = 5;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            if (fill) ctx.fill();
            if (stroke) ctx.stroke();
        }

        function shade(hex, percent) {
            // simple shade for head
            const c = hex.replace('#', '');
            const num = parseInt(c, 16);
            let r = (num >> 16) + percent;
            let g = ((num >> 8) & 0x00FF) + percent;
            let b = (num & 0x0000FF) + percent;
            r = Math.max(0, Math.min(255, r)); g = Math.max(0, Math.min(255, g)); b = Math.max(0, Math.min(255, b));
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        /* --- Restart handling --- */
        window.addEventListener('keydown', e => {
            if ((e.key === 'r' || e.key === 'R') && !running) {
                restart();
            }
        });

        function restart() {
            p1.reset(120, GROUND_Y - 56);
            p2.reset(W - 160, GROUND_Y - 56);
            running = true;
            winner = null;
            // clear keyState to avoid stuck "once" triggers
            for (let k in keyState) keyState[k] = false;
        }

        /* --- Extra: ensure Enter and Space work across browsers --- */
        /* (Handled by key checks above) */

        /* --- Initialize some keyState entries to avoid undefined --- */
        ['q', 'KeyQ', 'a', 'KeyA', 'd', 'KeyD', 'z', 'KeyZ', 'w', 'KeyW', ' ', 'Space', 'Spacebar', 'Enter', 'ArrowLeft', 'ArrowRight', 'ArrowUp'].forEach(k => keyState[k] = false);

        /* --- End of script --- */
    </script>
</body>

</html>