<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arkanoid Multijoueur 1v1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1e1e2e 0%, #2d1b4e 100%);
            font-family: 'Arial', sans-serif;
            color: white;
        }

        #gameContainer {
            text-align: center;
        }

        #gameCanvas {
            border: 4px solid #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            background: #0a0a0a;
        }

        #scoreBoard {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            font-size: 24px;
            font-weight: bold;
            width: 800px;
        }

        .player {
            padding: 10px 20px;
            border-radius: 10px;
            min-width: 200px;
        }

        .player1 {
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
        }

        .player2 {
            background: rgba(0, 150, 255, 0.2);
            border: 2px solid #0096ff;
        }

        #controls {
            margin-top: 20px;
            font-size: 14px;
            line-height: 1.8;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            max-width: 800px;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #00ffff;
            display: none;
            text-align: center;
            z-index: 10;
        }

        #gameOver h2 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px currentColor;
        }

        #gameOver button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 20px;
            background: #00ffff;
            color: #000;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        #gameOver button:hover {
            background: #00ff00;
            transform: scale(1.1);
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <div id="scoreBoard">
            <div class="player player1">
                <div>ðŸŸ¢ JOUEUR 1</div>
                <div>Score: <span id="score1">0</span></div>
                <div>Vies: <span id="lives1">3</span></div>
            </div>
            <div class="player player2">
                <div>ðŸ”µ JOUEUR 2</div>
                <div>Score: <span id="score2">0</span></div>
                <div>Vies: <span id="lives2">3</span></div>
            </div>
        </div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="controls">
            <strong>ðŸŽ® CONTRÃ”LES :</strong><br>
            Joueur 1 (Vert) : Z/S pour monter/descendre | ESPACE pour boost<br>
            Joueur 2 (Bleu) : â†‘/â†“ pour monter/descendre | ENTRÃ‰E pour boost
        </div>
    </div>
    <div id="gameOver">
        <h2 id="winnerText"></h2>
        <p id="finalScore"></p>
        <button onclick="restartGame()">REJOUER</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const PADDLE_WIDTH = 15;
        const PADDLE_HEIGHT = 100;
        const BALL_SIZE = 10;
        const BRICK_ROWS = 4;
        const BRICK_COLS = 6;
        const BRICK_WIDTH = 80;
        const BRICK_HEIGHT = 25;
        const BRICK_PADDING = 5;
        const BRICK_OFFSET_X = (canvas.width - (BRICK_COLS * (BRICK_WIDTH + BRICK_PADDING))) / 2;
        const BRICK_OFFSET_Y = 100;
        const MAX_LIVES = 3;
        const WINNING_SCORE = 10;
        const BOOST_DURATION = 1000;
        const BOOST_SPEED = 12;

        let gameState = {
            paddle1: { x: 20, y: canvas.height / 2 - PADDLE_HEIGHT / 2, speed: 8, boosting: false, boostEnd: 0 },
            paddle2: { x: canvas.width - 35, y: canvas.height / 2 - PADDLE_HEIGHT / 2, speed: 8, boosting: false, boostEnd: 0 },
            ball: { x: canvas.width / 2, y: canvas.height / 2, dx: 4, dy: 4, speed: 4 },
            bricks: [],
            score1: 0,
            score2: 0,
            lives1: MAX_LIVES,
            lives2: MAX_LIVES,
            keys: {},
            gameRunning: true,
            gameStarted: false
        };

        function initBricks() {
            gameState.bricks = [];
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    gameState.bricks.push({
                        x: BRICK_OFFSET_X + col * (BRICK_WIDTH + BRICK_PADDING),
                        y: BRICK_OFFSET_Y + row * (BRICK_HEIGHT + BRICK_PADDING),
                        width: BRICK_WIDTH,
                        height: BRICK_HEIGHT,
                        active: true,
                        hue: (row * 60 + col * 20) % 360
                    });
                }
            }
        }

        function drawPaddle(paddle, color) {
            ctx.fillStyle = paddle.boosting ? '#ffff00' : color;
            ctx.fillRect(paddle.x, paddle.y, PADDLE_WIDTH, PADDLE_HEIGHT);

            if (paddle.boosting) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffff00';
                ctx.fillRect(paddle.x, paddle.y, PADDLE_WIDTH, PADDLE_HEIGHT);
                ctx.shadowBlur = 0;
            }
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(gameState.ball.x, gameState.ball.y, BALL_SIZE, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffffff';
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.closePath();
        }

        function drawBricks() {
            gameState.bricks.forEach(brick => {
                if (brick.active) {
                    ctx.fillStyle = `hsl(${brick.hue}, 80%, 50%)`;
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                }
            });
        }

        function drawCenterLine() {
            ctx.setLineDash([10, 10]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function updatePaddles() {
            const now = Date.now();

            // Joueur 1
            if (gameState.paddle1.boosting && now > gameState.paddle1.boostEnd) {
                gameState.paddle1.boosting = false;
            }
            const speed1 = gameState.paddle1.boosting ? BOOST_SPEED : gameState.paddle1.speed;

            if (gameState.keys['z'] && gameState.paddle1.y > 0) {
                gameState.paddle1.y -= speed1;
            }
            if (gameState.keys['s'] && gameState.paddle1.y < canvas.height - PADDLE_HEIGHT) {
                gameState.paddle1.y += speed1;
            }

            // Joueur 2
            if (gameState.paddle2.boosting && now > gameState.paddle2.boostEnd) {
                gameState.paddle2.boosting = false;
            }
            const speed2 = gameState.paddle2.boosting ? BOOST_SPEED : gameState.paddle2.speed;

            if (gameState.keys['ArrowUp'] && gameState.paddle2.y > 0) {
                gameState.paddle2.y -= speed2;
            }
            if (gameState.keys['ArrowDown'] && gameState.paddle2.y < canvas.height - PADDLE_HEIGHT) {
                gameState.paddle2.y += speed2;
            }
        }

        function updateBall() {
            gameState.ball.x += gameState.ball.dx;
            gameState.ball.y += gameState.ball.dy;

            // Collision haut/bas
            if (gameState.ball.y - BALL_SIZE <= 0 || gameState.ball.y + BALL_SIZE >= canvas.height) {
                gameState.ball.dy = -gameState.ball.dy;
            }

            // Collision raquette gauche (Joueur 1)
            if (gameState.ball.x - BALL_SIZE <= gameState.paddle1.x + PADDLE_WIDTH &&
                gameState.ball.x >= gameState.paddle1.x &&
                gameState.ball.y >= gameState.paddle1.y &&
                gameState.ball.y <= gameState.paddle1.y + PADDLE_HEIGHT) {

                let hitPos = (gameState.ball.y - gameState.paddle1.y) / PADDLE_HEIGHT;
                let angle = (hitPos - 0.5) * Math.PI / 3;
                gameState.ball.dx = Math.abs(gameState.ball.dx) * 1.05;
                gameState.ball.dy = Math.sin(angle) * gameState.ball.speed * 1.05;
                gameState.ball.x = gameState.paddle1.x + PADDLE_WIDTH + BALL_SIZE;
                gameState.ball.speed *= 1.02;
            }

            // Collision raquette droite (Joueur 2)
            if (gameState.ball.x + BALL_SIZE >= gameState.paddle2.x &&
                gameState.ball.x <= gameState.paddle2.x + PADDLE_WIDTH &&
                gameState.ball.y >= gameState.paddle2.y &&
                gameState.ball.y <= gameState.paddle2.y + PADDLE_HEIGHT) {

                let hitPos = (gameState.ball.y - gameState.paddle2.y) / PADDLE_HEIGHT;
                let angle = (hitPos - 0.5) * Math.PI / 3;
                gameState.ball.dx = -Math.abs(gameState.ball.dx) * 1.05;
                gameState.ball.dy = Math.sin(angle) * gameState.ball.speed * 1.05;
                gameState.ball.x = gameState.paddle2.x - BALL_SIZE;
                gameState.ball.speed *= 1.02;
            }

            // Collision briques
            gameState.bricks.forEach(brick => {
                if (brick.active &&
                    gameState.ball.x + BALL_SIZE > brick.x &&
                    gameState.ball.x - BALL_SIZE < brick.x + brick.width &&
                    gameState.ball.y + BALL_SIZE > brick.y &&
                    gameState.ball.y - BALL_SIZE < brick.y + brick.height) {

                    brick.active = false;
                    gameState.ball.dy = -gameState.ball.dy;

                    if (gameState.ball.x < canvas.width / 2) {
                        gameState.score1++;
                    } else {
                        gameState.score2++;
                    }

                    updateScores();
                }
            });

            // Perte de vie
            if (gameState.ball.x - BALL_SIZE <= 0) {
                gameState.lives1--;
                gameState.score2++;
                resetBall();
                updateScores();
            }
            if (gameState.ball.x + BALL_SIZE >= canvas.width) {
                gameState.lives2--;
                gameState.score1++;
                resetBall();
                updateScores();
            }

            checkGameOver();
        }

        function resetBall() {
            gameState.ball.x = canvas.width / 2;
            gameState.ball.y = canvas.height / 2;
            gameState.ball.dx = (Math.random() > 0.5 ? 1 : -1) * 4;
            gameState.ball.dy = (Math.random() - 0.5) * 4;
            gameState.ball.speed = 4;
        }

        function updateScores() {
            document.getElementById('score1').textContent = gameState.score1;
            document.getElementById('score2').textContent = gameState.score2;
            document.getElementById('lives1').textContent = gameState.lives1;
            document.getElementById('lives2').textContent = gameState.lives2;
        }

        function checkGameOver() {
            if (gameState.score1 >= WINNING_SCORE || gameState.lives2 <= 0) {
                endGame('JOUEUR 1 GAGNE! ðŸŸ¢');
            } else if (gameState.score2 >= WINNING_SCORE || gameState.lives1 <= 0) {
                endGame('JOUEUR 2 GAGNE! ðŸ”µ');
            }
        }

        function endGame(winner) {
            gameState.gameRunning = false;
            document.getElementById('winnerText').textContent = winner;
            document.getElementById('finalScore').textContent =
                `Score Final: ${gameState.score1} - ${gameState.score2}`;
            document.getElementById('gameOver').style.display = 'block';
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawCenterLine();
            drawBricks();
            drawPaddle(gameState.paddle1, '#00ff00');
            drawPaddle(gameState.paddle2, '#0096ff');
            drawBall();

            if (!gameState.gameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = '32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Appuyez sur ESPACE ou ENTRÃ‰E pour commencer', canvas.width / 2, canvas.height / 2);
            }
        }

        function gameLoop() {
            if (gameState.gameRunning) {
                if (gameState.gameStarted) {
                    updatePaddles();
                    updateBall();
                }
                draw();
                requestAnimationFrame(gameLoop);
            }
        }

        function restartGame() {
            gameState.score1 = 0;
            gameState.score2 = 0;
            gameState.lives1 = MAX_LIVES;
            gameState.lives2 = MAX_LIVES;
            gameState.paddle1.y = canvas.height / 2 - PADDLE_HEIGHT / 2;
            gameState.paddle2.y = canvas.height / 2 - PADDLE_HEIGHT / 2;
            gameState.gameRunning = true;
            gameState.gameStarted = false;
            document.getElementById('gameOver').style.display = 'none';
            initBricks();
            resetBall();
            updateScores();
            gameLoop();
        }

        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key.toLowerCase()] = true;

            if (!gameState.gameStarted && (e.key === ' ' || e.key === 'Enter')) {
                gameState.gameStarted = true;
            }

            if (e.key === ' ' && !gameState.paddle1.boosting) {
                gameState.paddle1.boosting = true;
                gameState.paddle1.boostEnd = Date.now() + BOOST_DURATION;
            }

            if (e.key === 'Enter' && !gameState.paddle2.boosting) {
                gameState.paddle2.boosting = true;
                gameState.paddle2.boostEnd = Date.now() + BOOST_DURATION;
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });

        initBricks();
        updateScores();
        gameLoop();
    </script>
</body>

</html>