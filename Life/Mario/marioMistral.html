<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mario-like Canvas Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #222;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #000;
            background: #68a;
        }
    </style>
</head>
<body>
    <canvas id="game" width="800" height="400"></canvas>
    <script>
        // CONFIG & CONSTANTS
        const GRAVITY = 0.6;
        const JUMP_FORCE = 12;
        const PLAYER_SPEED = 5;
        const ENEMY_SPEED = 2;
        const TILE_SIZE = 40;
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 400;

        // CORE ENGINE
        class Game {
            constructor() {
                this.canvas = document.getElementById('game');
                this.ctx = this.canvas.getContext('2d');
                this.lastTime = 0;
                this.deltaTime = 0;
                this.scrollOffset = 0;
                this.entities = [];
                this.world = new World();
                this.player = new Player(100, 100);
                this.enemyManager = new EnemyManager();
                this.input = new InputManager();
                this.init();
            }

            init() {
                this.entities.push(this.player);
                this.enemyManager.addEnemy(500, CANVAS_HEIGHT - TILE_SIZE * 2);
                this.enemyManager.addEnemy(800, CANVAS_HEIGHT - TILE_SIZE * 4);
                this.world.generate();
                requestAnimationFrame(this.loop.bind(this));
            }

            loop(timestamp) {
                this.deltaTime = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;
                this.update();
                this.render();
                requestAnimationFrame(this.loop.bind(this));
            }

            update() {
                this.player.update(this.input, this.deltaTime, this.world);
                this.enemyManager.update(this.deltaTime, this.world, this.player);
                this.scrollOffset = Math.max(0, this.player.x - CANVAS_WIDTH / 3);
            }

            render() {
                this.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                this.ctx.save();
                this.ctx.translate(-this.scrollOffset, 0);
                this.world.render(this.ctx);
                this.player.render(this.ctx);
                this.enemyManager.render(this.ctx);
                this.ctx.restore();
            }
        }

        // INPUT MANAGER
        class InputManager {
            constructor() {
                this.keys = {};
                window.addEventListener('keydown', (e) => this.keys[e.code] = true);
                window.addEventListener('keyup', (e) => this.keys[e.code] = false);
            }
        }

        // ENTITY BASE CLASS
        class Entity {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.velX = 0;
                this.velY = 0;
            }

            update(deltaTime, world) {
                this.velY += GRAVITY;
                this.x += this.velX;
                this.y += this.velY;
                world.resolveCollisions(this);
            }

            render(ctx) {
                ctx.fillStyle = '#e55';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        // PLAYER (Mario)
        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 30, 50);
                this.jumping = false;
            }

            update(input, deltaTime, world) {
                this.velX = 0;
                if (input.keys['ArrowLeft']) this.velX = -PLAYER_SPEED;
                if (input.keys['ArrowRight']) this.velX = PLAYER_SPEED;
                if (input.keys['Space'] && !this.jumping) {
                    this.velY = -JUMP_FORCE;
                    this.jumping = true;
                }
                super.update(deltaTime, world);
            }

            render(ctx) {
                ctx.fillStyle = '#e55';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        // ENEMY
        class Enemy extends Entity {
            constructor(x, y) {
                super(x, y, 30, 30);
                this.velX = -ENEMY_SPEED;
                this.direction = -1;
            }

            update(deltaTime, world) {
                super.update(deltaTime, world);
            }

            render(ctx) {
                ctx.fillStyle = '#a55';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            reverseDirection() {
                this.velX *= -1;
                this.direction *= -1;
            }
        }

        // ENEMY MANAGER
        class EnemyManager {
            constructor() {
                this.enemies = [];
            }

            addEnemy(x, y) {
                this.enemies.push(new Enemy(x, y));
            }

            update(deltaTime, world, player) {
                this.enemies.forEach(enemy => {
                    enemy.update(deltaTime, world);
                    this.checkPlayerCollision(enemy, player);
                    this.checkWorldBounds(enemy);
                });
            }

            checkPlayerCollision(enemy, player) {
                if (player.x + player.width > enemy.x &&
                    player.x < enemy.x + enemy.width &&
                    player.y + player.height > enemy.y &&
                    player.y < enemy.y + enemy.height) {
                    if (player.velY > 0 && player.y + player.height - player.velY <= enemy.y) {
                        // Player jumps on enemy
                        player.velY = -JUMP_FORCE * 0.8;
                        this.enemies.splice(this.enemies.indexOf(enemy), 1);
                    }
                }
            }

            checkWorldBounds(enemy) {
                if (enemy.x <= 0 || enemy.x + enemy.width >= 2000) {
                    enemy.reverseDirection();
                }
            }

            render(ctx) {
                this.enemies.forEach(enemy => enemy.render(ctx));
            }
        }

        // WORLD (sol, plateformes)
        class World {
            constructor() {
                this.platforms = [];
            }

            generate() {
                this.platforms = [
                    { x: 0, y: CANVAS_HEIGHT - TILE_SIZE, width: 2000, height: TILE_SIZE },
                    { x: 400, y: CANVAS_HEIGHT - TILE_SIZE * 3, width: 200, height: TILE_SIZE },
                    { x: 700, y: CANVAS_HEIGHT - TILE_SIZE * 5, width: 200, height: TILE_SIZE },
                    { x: 1200, y: CANVAS_HEIGHT - TILE_SIZE * 2, width: 200, height: TILE_SIZE },
                ];
            }

            resolveCollisions(entity) {
                for (const p of this.platforms) {
                    if (entity.x + entity.width > p.x && entity.x < p.x + p.width &&
                        entity.y + entity.height > p.y && entity.y < p.y + p.height) {
                        if (entity.velY > 0 && entity.y + entity.height - entity.velY <= p.y) {
                            entity.y = p.y - entity.height;
                            entity.velY = 0;
                            if (entity instanceof Player) entity.jumping = false;
                        }
                    }
                }
            }

            render(ctx) {
                ctx.fillStyle = '#5a5';
                this.platforms.forEach(p => ctx.fillRect(p.x, p.y, p.width, p.height));
            }
        }

        // FUTURE EXTENSIONS HOOKS

        // FUTURE : ItemManager (power-ups)
        class ItemManager {
            constructor() {
                this.items = [];
            }
            update(deltaTime, world) {}
            render(ctx) {}
        }

        // FUTURE : LevelManager (multi-niveaux)
        class LevelManager {
            constructor() {
                this.levels = [];
                this.currentLevel = 0;
            }
            loadLevel(index) {}
        }

        // FUTURE : AudioSystem
        class AudioSystem {
            constructor() {
                this.sounds = {};
            }
            play(soundName) {}
        }

        // FUTURE : SpriteSystem
        class SpriteSystem {
            constructor() {
                this.sprites = {};
            }
            drawSprite(ctx, spriteName, x, y) {}
        }

        // FUTURE : SaveSystem
        class SaveSystem {
            constructor() {
                this.data = {};
            }
            save() {}
            load() {}
        }

        // INIT GAME
        window.onload = () => new Game();
    </script>
</body>
</html>
