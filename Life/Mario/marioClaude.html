<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mario HTML5</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #5c94fc; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #gameCanvas { 
            border: 4px solid #000; 
            background: #5c94fc;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            z-index: 10;
            display: flex;
            gap: 40px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Vies: <span id="lives">3</span></div>
        <div>Pi√®ces: <span id="coins">0</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script>
        
// ============================================
// CONFIG & CONSTANTS
// ============================================
const CONFIG = {
    CANVAS_WIDTH: 800,
    CANVAS_HEIGHT: 600,
    GRAVITY: 0.6,
    FRICTION: 0.85,
    PLAYER_SPEED: 5,
    PLAYER_JUMP: -15,
    TILE_SIZE: 32,
    ENEMY_SPEED: 1.5,
    STOMP_BOUNCE: -10
};

// ============================================
// CORE ENGINE
// ============================================
class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = CONFIG.CANVAS_WIDTH;
        this.canvas.height = CONFIG.CANVAS_HEIGHT;
        
        this.camera = { x: 0, y: 0 };
        this.running = false;
        this.lastTime = 0;
        this.deltaTime = 0;
        this.gameOver = false;
        this.score = 0;
        this.lives = 3;
        this.coins = 0;
    }
    
    start() {
        this.running = true;
        this.lastTime = performance.now();
        this.loop();
    }
    
    loop(currentTime = 0) {
        if (!this.running) return;
        
        this.deltaTime = (currentTime - this.lastTime) / 16.67;
        this.lastTime = currentTime;
        
        this.update();
        this.render();
        
        requestAnimationFrame((time) => this.loop(time));
    }
    
    update() {
        if (this.gameOver) return;
        
        game.world.update();
        game.player.update();
        game.enemyManager.update();
        game.itemManager.update();
        this.updateCamera();
        this.updateUI();
    }
    
    updateCamera() {
        const targetX = game.player.x - CONFIG.CANVAS_WIDTH / 3;
        this.camera.x = Math.max(0, targetX);
    }
    
    updateUI() {
        document.getElementById('score').textContent = this.score;
        document.getElementById('lives').textContent = this.lives;
        document.getElementById('coins').textContent = this.coins;
    }
    
    addScore(points) {
        this.score += points;
    }
    
    addCoin() {
        this.coins++;
        this.addScore(100);
    }
    
    loseLife() {
        this.lives--;
        if (this.lives <= 0) {
            this.gameOver = true;
            setTimeout(() => this.restart(), 2000);
        } else {
            game.player.respawn();
        }
    }
    
    restart() {
        this.score = 0;
        this.lives = 3;
        this.coins = 0;
        this.gameOver = false;
        game.player.respawn();
        game.enemyManager.reset();
        game.itemManager.reset();
    }
    
    render() {
        this.ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
        this.ctx.save();
        this.ctx.translate(-this.camera.x, -this.camera.y);
        
        game.world.render(this.ctx);
        game.itemManager.render(this.ctx);
        game.enemyManager.render(this.ctx);
        game.player.render(this.ctx);
        
        this.ctx.restore();
        
        if (this.gameOver) {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '48px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('GAME OVER', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2);
            this.ctx.font = '24px Arial';
            this.ctx.fillText('Score: ' + this.score, CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 + 50);
        }
    }
}

// ============================================
// INPUT MANAGER
// ============================================
class InputManager {
    constructor() {
        this.keys = {};
        this.bindEvents();
    }
    
    bindEvents() {
        window.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
        });
    }
    
    isPressed(key) {
        return this.keys[key] || false;
    }
}

// ============================================
// ENTITY BASE CLASS
// ============================================
class Entity {
    constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.vx = 0;
        this.vy = 0;
        this.active = true;
    }
    
    applyGravity() {
        this.vy += CONFIG.GRAVITY;
    }
    
    applyFriction() {
        this.vx *= CONFIG.FRICTION;
    }
    
    intersects(other) {
        return this.x < other.x + other.width &&
               this.x + this.width > other.x &&
               this.y < other.y + other.height &&
               this.y + this.height > other.y;
    }
    
    update() {}
    render(ctx) {}
}

// ============================================
// PLAYER (Mario)
// ============================================
class Player extends Entity {
    constructor(x, y) {
        super(x, y, 32, 32);
        this.onGround = false;
        this.direction = 1;
        this.spawnX = x;
        this.spawnY = y;
        this.invincible = false;
        this.invincibleTime = 0;
    }
    
    update() {
        this.handleInput();
        this.applyGravity();
        this.applyFriction();
        
        this.x += this.vx;
        this.y += this.vy;
        
        this.checkCollisions();
        this.checkEnemyCollisions();
        this.checkItemCollisions();
        
        if (Math.abs(this.vx) < 0.1) this.vx = 0;
        
        if (this.invincible) {
            this.invincibleTime--;
            if (this.invincibleTime <= 0) {
                this.invincible = false;
            }
        }
        
        if (this.y > CONFIG.CANVAS_HEIGHT + 100) {
            game.engine.loseLife();
        }
    }
    
    handleInput() {
        if (game.input.isPressed('ArrowLeft')) {
            this.vx = -CONFIG.PLAYER_SPEED;
            this.direction = -1;
        }
        if (game.input.isPressed('ArrowRight')) {
            this.vx = CONFIG.PLAYER_SPEED;
            this.direction = 1;
        }
        if ((game.input.isPressed('Space') || game.input.isPressed('ArrowUp')) && this.onGround) {
            this.vy = CONFIG.PLAYER_JUMP;
            this.onGround = false;
        }
    }
    
    checkCollisions() {
        this.onGround = false;
        const platforms = game.world.platforms;
        
        for (let platform of platforms) {
            if (this.intersects(platform)) {
                const overlapX = Math.min(
                    this.x + this.width - platform.x,
                    platform.x + platform.width - this.x
                );
                const overlapY = Math.min(
                    this.y + this.height - platform.y,
                    platform.y + platform.height - this.y
                );
                
                if (overlapX < overlapY) {
                    if (this.x < platform.x) {
                        this.x = platform.x - this.width;
                    } else {
                        this.x = platform.x + platform.width;
                    }
                    this.vx = 0;
                } else {
                    if (this.y < platform.y) {
                        this.y = platform.y - this.height;
                        this.vy = 0;
                        this.onGround = true;
                    } else {
                        this.y = platform.y + platform.height;
                        this.vy = 0;
                    }
                }
            }
        }
    }
    
    checkEnemyCollisions() {
        if (this.invincible) return;
        
        for (let enemy of game.enemyManager.enemies) {
            if (!enemy.active) continue;
            
            if (this.intersects(enemy)) {
                const fromAbove = this.vy > 0 && this.y + this.height - 10 < enemy.y + enemy.height / 2;
                
                if (fromAbove) {
                    enemy.die();
                    this.vy = CONFIG.STOMP_BOUNCE;
                    game.engine.addScore(enemy.points);
                } else {
                    this.takeDamage();
                }
            }
        }
    }
    
    checkItemCollisions() {
        for (let item of game.itemManager.items) {
            if (!item.active) continue;
            
            if (this.intersects(item)) {
                item.collect();
            }
        }
    }
    
    takeDamage() {
        if (this.invincible) return;
        game.engine.loseLife();
    }
    
    respawn() {
        this.x = this.spawnX;
        this.y = this.spawnY;
        this.vx = 0;
        this.vy = 0;
        this.invincible = true;
        this.invincibleTime = 120;
    }
    
    render(ctx) {
        if (this.invincible && Math.floor(this.invincibleTime / 5) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(this.x + 8, this.y + 2, 16, 8);
        
        ctx.fillStyle = '#ffdbac';
        ctx.fillRect(this.x + 6, this.y + 10, 20, 12);
        
        ctx.fillStyle = '#0000ff';
        ctx.fillRect(this.x + 4, this.y + 22, 24, 10);
        
        if (this.direction > 0) {
            ctx.fillStyle = '#000';
            ctx.fillRect(this.x + 18, this.y + 12, 3, 3);
        } else {
            ctx.fillStyle = '#000';
            ctx.fillRect(this.x + 11, this.y + 12, 3, 3);
        }
        
        ctx.globalAlpha = 1.0;
    }
}

// ============================================
// ENEMY CLASSES
// ============================================
class Enemy extends Entity {
    constructor(x, y, width, height, type) {
        super(x, y, width, height);
        this.type = type;
        this.direction = -1;
        this.speed = CONFIG.ENEMY_SPEED;
        this.points = 100;
        this.animFrame = 0;
    }
    
    update() {
        if (!this.active) return;
        
        this.applyGravity();
        this.vx = this.speed * this.direction;
        this.x += this.vx;
        this.y += this.vy;
        
        this.checkPlatformCollisions();
        this.checkEnemyCollisions();
        
        this.animFrame++;
    }
    
    checkPlatformCollisions() {
        let onGround = false;
        const platforms = game.world.platforms;
        
        for (let platform of platforms) {
            if (this.intersects(platform)) {
                const overlapX = Math.min(
                    this.x + this.width - platform.x,
                    platform.x + platform.width - this.x
                );
                const overlapY = Math.min(
                    this.y + this.height - platform.y,
                    platform.y + platform.height - this.y
                );
                
                if (overlapX < overlapY) {
                    if (this.x < platform.x) {
                        this.x = platform.x - this.width;
                        this.direction = -1;
                    } else {
                        this.x = platform.x + platform.width;
                        this.direction = 1;
                    }
                } else {
                    if (this.y < platform.y) {
                        this.y = platform.y - this.height;
                        this.vy = 0;
                        onGround = true;
                    } else {
                        this.y = platform.y + platform.height;
                        this.vy = 0;
                    }
                }
            }
        }
        
        if (this.y > CONFIG.CANVAS_HEIGHT) {
            this.active = false;
        }
    }
    
    checkEnemyCollisions() {
        for (let enemy of game.enemyManager.enemies) {
            if (enemy === this || !enemy.active) continue;
            
            if (this.intersects(enemy)) {
                this.direction *= -1;
                enemy.direction *= -1;
                
                if (this.x < enemy.x) {
                    this.x = enemy.x - this.width - 1;
                } else {
                    this.x = enemy.x + enemy.width + 1;
                }
            }
        }
    }
    
    die() {
        this.active = false;
    }
    
    render(ctx) {
        if (!this.active) return;
    }
}

class Goomba extends Enemy {
    constructor(x, y) {
        super(x, y, 28, 28, 'goomba');
        this.points = 100;
    }
    
    render(ctx) {
        if (!this.active) return;
        
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        ctx.fillStyle = '#654321';
        ctx.fillRect(this.x + 4, this.y, 20, 12);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(this.x + 6, this.y + 8, 6, 4);
        ctx.fillRect(this.x + 16, this.y + 8, 6, 4);
        
        const walkOffset = Math.floor(this.animFrame / 15) % 2 === 0 ? 0 : 2;
        ctx.fillStyle = '#654321';
        ctx.fillRect(this.x + 2, this.y + 24 + walkOffset, 8, 4);
        ctx.fillRect(this.x + 18, this.y + 24 - walkOffset, 8, 4);
    }
}

class Koopa extends Enemy {
    constructor(x, y) {
        super(x, y, 32, 40, 'koopa');
        this.points = 200;
        this.speed = CONFIG.ENEMY_SPEED * 0.8;
    }
    
    render(ctx) {
        if (!this.active) return;
        
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(this.x + 6, this.y, 20, 24);
        
        ctx.fillStyle = '#006400';
        for (let i = 0; i < 3; i++) {
            ctx.fillRect(this.x + 8 + i * 6, this.y + 4 + i * 4, 8, 4);
        }
        
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(this.x + 4, this.y + 24, 24, 12);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(this.x + 10, this.y + 28, 4, 4);
        ctx.fillRect(this.x + 18, this.y + 28, 4, 4);
        
        const walkOffset = Math.floor(this.animFrame / 20) % 2 === 0 ? 0 : 2;
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(this.x + 2, this.y + 36 + walkOffset, 10, 4);
        ctx.fillRect(this.x + 20, this.y + 36 - walkOffset, 10, 4);
    }
}

// ============================================
// ITEM CLASSES
// ============================================
class Item extends Entity {
    constructor(x, y, width, height, type) {
        super(x, y, width, height);
        this.type = type;
    }
    
    collect() {
        this.active = false;
    }
    
    update() {
        if (!this.active) return;
    }
}

class Coin extends Item {
    constructor(x, y) {
        super(x, y, 24, 24, 'coin');
        this.animFrame = 0;
    }
    
    collect() {
        super.collect();
        game.engine.addCoin();
    }
    
    update() {
        if (!this.active) return;
        this.animFrame++;
    }
    
    render(ctx) {
        if (!this.active) return;
        
        const pulse = Math.sin(this.animFrame / 10) * 2;
        
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 10 + pulse, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#daa520';
        ctx.beginPath();
        ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 6, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ============================================
// WORLD (Sol et Plateformes)
// ============================================
class Platform {
    constructor(x, y, width, height, type = 'ground') {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.type = type;
    }
    
    render(ctx) {
        if (this.type === 'ground') {
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#654321';
            for (let i = 0; i < this.width; i += CONFIG.TILE_SIZE) {
                for (let j = 0; j < this.height; j += CONFIG.TILE_SIZE) {
                    ctx.strokeStyle = '#654321';
                    ctx.strokeRect(this.x + i, this.y + j, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                }
            }
        } else if (this.type === 'brick') {
            ctx.fillStyle = '#c84c09';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.strokeStyle = '#8b3506';
            ctx.lineWidth = 2;
            for (let i = 0; i < this.width; i += 16) {
                ctx.strokeRect(this.x + i, this.y, 16, this.height);
            }
        } else {
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.strokeStyle = '#daa520';
            ctx.strokeRect(this.x + 2, this.y + 2, this.width - 4, this.height - 4);
            ctx.fillStyle = '#fff';
            ctx.fillRect(this.x + 8, this.y + 8, 8, 8);
        }
    }
}

class World {
    constructor() {
        this.platforms = [];
        this.loadLevel();
    }
    
    loadLevel() {
        this.platforms.push(new Platform(0, 500, 3200, 100, 'ground'));
        
        this.platforms.push(new Platform(300, 400, 128, 32, 'brick'));
        this.platforms.push(new Platform(500, 350, 96, 32, 'brick'));
        this.platforms.push(new Platform(700, 300, 128, 32, 'brick'));
        this.platforms.push(new Platform(900, 400, 64, 32, 'mystery'));
        this.platforms.push(new Platform(1100, 350, 96, 32, 'brick'));
        this.platforms.push(new Platform(1300, 250, 128, 32, 'brick'));
        this.platforms.push(new Platform(1500, 400, 64, 32, 'mystery'));
        this.platforms.push(new Platform(1700, 350, 160, 32, 'brick'));
        this.platforms.push(new Platform(2000, 300, 96, 32, 'brick'));
        this.platforms.push(new Platform(2200, 400, 64, 32, 'mystery'));
        this.platforms.push(new Platform(2400, 350, 128, 32, 'brick'));
        this.platforms.push(new Platform(2700, 250, 160, 32, 'brick'));
    }
    
    update() {}
    
    render(ctx) {
        ctx.fillStyle = '#5c94fc';
        ctx.fillRect(0, 0, 3200, CONFIG.CANVAS_HEIGHT);
        
        for (let platform of this.platforms) {
            platform.render(ctx);
        }
    }
}

// ============================================
// ENEMY MANAGER
// ============================================
class EnemyManager {
    constructor() {
        this.enemies = [];
        this.spawnEnemies();
    }
    
    spawnEnemies() {
        this.enemies.push(new Goomba(400, 350));
        this.enemies.push(new Goomba(600, 300));
        this.enemies.push(new Koopa(800, 250));
        this.enemies.push(new Goomba(1000, 350));
        this.enemies.push(new Goomba(1200, 300));
        this.enemies.push(new Koopa(1400, 200));
        this.enemies.push(new Goomba(1600, 300));
        this.enemies.push(new Koopa(1800, 300));
        this.enemies.push(new Goomba(2100, 250));
        this.enemies.push(new Goomba(2300, 350));
        this.enemies.push(new Koopa(2500, 300));
        this.enemies.push(new Goomba(2800, 200));
    }
    
    update() {
        for (let enemy of this.enemies) {
            if (enemy.active) {
                enemy.update();
            }
        }
    }
    
    render(ctx) {
        for (let enemy of this.enemies) {
            if (enemy.active) {
                enemy.render(ctx);
            }
        }
    }
    
    reset() {
        this.enemies = [];
        this.spawnEnemies();
    }
}

// ============================================
// ITEM MANAGER
// ============================================
class ItemManager {
    constructor() {
        this.items = [];
        this.spawnItems();
    }
    
    spawnItems() {
        this.items.push(new Coin(350, 350));
        this.items.push(new Coin(550, 300));
        this.items.push(new Coin(750, 250));
        this.items.push(new Coin(950, 350));
        this.items.push(new Coin(1150, 300));
        this.items.push(new Coin(1350, 200));
        this.items.push(new Coin(1550, 350));
        this.items.push(new Coin(1750, 300));
        this.items.push(new Coin(2050, 250));
        this.items.push(new Coin(2250, 350));
        this.items.push(new Coin(2450, 300));
        this.items.push(new Coin(2750, 200));
    }
    
    update() {
        for (let item of this.items) {
            if (item.active) {
                item.update();
            }
        }
    }
    
    render(ctx) {
        for (let item of this.items) {
            if (item.active) {
                item.render(ctx);
            }
        }
    }
    
    reset() {
        this.items = [];
        this.spawnItems();
    }
}

// ============================================
// LEVEL LOADER
// ============================================
class LevelManager {
    constructor() {
        this.currentLevel = 1;
    }
    
    loadLevel(levelNumber) {
        this.currentLevel = levelNumber;
    }
}

// ============================================
// RENDERER
// ============================================
class Renderer {
    static drawText(ctx, text, x, y, size = 20, color = '#fff') {
        ctx.fillStyle = color;
        ctx.font = `${size}px Arial`;
        ctx.fillText(text, x, y);
    }
}

// ============================================
// FUTURE EXTENSIONS HOOKS
// ============================================

// AUDIO SYSTEM (Placeholder)
class AudioSystem {
    constructor() {
        this.sounds = {};
    }
    
    play(soundName) {}
    
    stop(soundName) {}
}

// SPRITE SYSTEM (Placeholder)
class SpriteSystem {
    constructor() {
        this.sprites = {};
    }
    
    loadSprite(name, data) {}
    
    drawSprite(ctx, name, x, y) {}
}

// SAVE SYSTEM (Placeholder)
class SaveSystem {
    constructor() {
        this.data = {};
    }
    
    save(key, value) {}
    
    load(key) {}
}

// ============================================
// GAME INITIALIZATION
// ============================================
const game = {
    engine: null,
    player: null,
    world: null,
    input: null,
    levelManager: null,
    enemyManager: null,
    itemManager: null,
    audioSystem: null,
    spriteSystem: null,
    saveSystem: null
};

function init() {
    game.engine = new GameEngine();
    game.input = new InputManager();
    game.world = new World();
    game.player = new Player(100, 100);
    game.levelManager = new LevelManager();
    game.enemyManager = new EnemyManager();
    game.itemManager = new ItemManager();
    game.audioSystem = new AudioSystem();
    game.spriteSystem = new SpriteSystem();
    game.saveSystem = new SaveSystem();
    
    game.engine.start();
}

init();

    </script>
</body>
</html>
