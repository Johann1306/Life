<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Neon Co-op Shmup — 2 Players</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #050007;
            font-family: Inter, system-ui, Segoe UI, Roboto, Arial;
            color: #fff;
            overflow: hidden
        }

        canvas {
            display: block;
            margin: 0 auto;
            background: #000;
            filter: none;
        }

        #ui {
            position: fixed;
            left: 0;
            right: 0;
            top: 0;
            padding: 8px 12px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #e6f7ff;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.06);
        }

        #info {
            display: flex;
            gap: 20px;
            align-items: center
        }

        .score {
            font-size: 18px;
            letter-spacing: 1px
        }

        .wave {
            font-size: 14px;
            color: #ff8bd6
        }

        .hint {
            font-size: 13px;
            color: #8fb7ff;
            opacity: .9
        }

        .lives {
            display: flex;
            gap: 6px;
            align-items: center
        }

        .centerMsg {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(90deg, rgba(255, 0, 150, 0.06), rgba(0, 200, 255, 0.04));
            padding: 12px 18px;
            border-radius: 12px;
            backdrop-filter: blur(6px);
            color: #bfefff;
            border: 1px solid rgba(255, 255, 255, 0.04);
            text-align: center;
        }

        a.small {
            color: #9ee7ff;
            text-decoration: none
        }

        footer {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 8px;
            text-align: center;
            font-size: 12px;
            color: #6e9dbf;
            opacity: .8
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="info">
            <div class="score" id="score">SCORE: 0</div>
            <div class="wave" id="wave">WAVE: 0</div>
            <div class="hint" id="hint">P1: ZQSD + Space • P2: Arrows + Enter • R = Restart</div>
        </div>
        <div class="lives" id="lives"></div>
    </div>

    <canvas id="c"></canvas>
    <div id="center" class="centerMsg" style="display:none"></div>
    <footer>Neon Co-op Shmup — Local 2 players — No assets, canvas only</footer>

    <script>
        /* ---------- Config ---------- */
        const WIDTH = Math.min(1000, Math.floor(window.innerWidth * 0.98));
        const HEIGHT = Math.min(1400, Math.floor(window.innerHeight * 0.94));
        const canvas = document.getElementById('c');
        canvas.width = WIDTH; canvas.height = HEIGHT;
        const ctx = canvas.getContext('2d', { alpha: false });
        ctx.imageSmoothingEnabled = true;

        let keys = {}; // true = pressed
        let prevKeys = {};
        window.addEventListener('keydown', e => { keys[e.code] = true; e.preventDefault?.(); });
        window.addEventListener('keyup', e => { keys[e.code] = false; e.preventDefault?.(); });

        /* ---------- Utils ---------- */
        const rand = (a, b) => a + Math.random() * (b - a);
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const dist2 = (a, b) => { const dx = a.x - b.x, dy = a.y - b.y; return dx * dx + dy * dy; }
        const now = () => performance.now();

        /* ---------- Game State ---------- */
        let score = 0;
        let wave = 0;
        let running = true;
        let lastTime = now();
        let accum = 0;
        const UI_SCORE = document.getElementById('score');
        const UI_WAVE = document.getElementById('wave');
        const UI_LIVES = document.getElementById('lives');
        const CENTER = document.getElementById('center');

        /* ---------- Stars Parallax ---------- */
        const starsLayers = [
            { count: 120, speed: 30, color: '#1b2539', size: 1, stars: [] },
            { count: 70, speed: 60, color: '#335', size: 1.4, stars: [] },
            { count: 40, speed: 120, color: '#59f', size: 1.8, stars: [] }
        ];
        for (let L of starsLayers) {
            for (let i = 0; i < L.count; i++) {
                L.stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, s: L.size, tw: rand(0.6, 1.4) });
            }
        }

        /* ---------- Entities ---------- */
        const players = [
            // P1: red/orange (ZQSD + Space)
            { id: 1, x: WIDTH * 0.25, y: HEIGHT - 120, w: 28, h: 36, color1: '#ff6b2d', color2: '#ffedb2', cooldown: 0, lives: 3, score: 0, power: 0, shield: 0, alive: true, respawnTimer: 0 },
            // P2: blue/cyan (Arrows + Enter)
            { id: 2, x: WIDTH * 0.75, y: HEIGHT - 120, w: 28, h: 36, color1: '#2dd7ff', color2: '#bff7ff', cooldown: 0, lives: 3, score: 0, power: 0, shield: 0, alive: true, respawnTimer: 0 }
        ];

        let bullets = []; // friendly
        let enemyBullets = [];
        let enemies = [];
        let particles = [];
        let powerups = [];

        const MAX_PARTICLES = 800;

        /* ---------- Pools Helpers ---------- */
        function spawnBullet(x, y, dx, dy, owner, cfg = {}) {
            bullets.push(Object.assign({ x, y, dx, dy, owner, life: 120, r: 3, glow: 1 }, cfg));
        }
        function spawnEnemyBullet(x, y, dx, dy, cfg = {}) { enemyBullets.push(Object.assign({ x, y, dx, dy, life: 300, r: 4, glow: 2 }, cfg)); }
        function spawnParticle(x, y, vx, vy, color, life) {
            if (particles.length > MAX_PARTICLES) return;
            particles.push({ x, y, vx, vy, color, life, age: 0, r: rand(1, 3) });
        }
        function spawnPowerup(x, y, type) {
            powerups.push({ x, y, type, vy: 50, wob: Math.random() * Math.PI * 2, ttl: 15000, spawn: now() });
        }

        /* ---------- Controls mapping ---------- */
        // We track pressed keys by .code
        function control(player, dt) {
            if (!player.alive) return;
            const speed = 260 + (player.power ? 40 : 0);
            let vx = 0, vy = 0;
            if (player.id === 1) {
                if (keys['KeyZ']) vy -= 1;
                if (keys['KeyS']) vy += 1;
                if (keys['KeyQ']) vx -= 1;
                if (keys['KeyD']) vx += 1;
                if (keys['Space'] && player.cooldown <= 0) { firePlayer(player); player.cooldown = player.power >= 2 ? 180 : 260; }
            } else {
                if (keys['ArrowUp']) vy -= 1;
                if (keys['ArrowDown']) vy += 1;
                if (keys['ArrowLeft']) vx -= 1;
                if (keys['ArrowRight']) vx += 1;
                if (keys['Enter'] && player.cooldown <= 0) { firePlayer(player); player.cooldown = player.power >= 2 ? 180 : 260; }
            }
            // normalize
            if (vx !== 0 && vy !== 0) { vx *= 0.7071; vy *= 0.7071; }
            player.x += vx * speed * dt;
            player.y += vy * speed * dt;
            // clamp
            player.x = clamp(player.x, 24, WIDTH - 24);
            player.y = clamp(player.y, HEIGHT * 0.45, HEIGHT - 40);
        }

        /* ---------- Firing ---------- */
        function firePlayer(p) {
            const muzzle = { x: p.x, y: p.y - 18 };
            if (p.power >= 2) {
                // triple shot
                spawnBullet(muzzle.x, muzzle.y, 0, -600, p.id, { r: 3, color: p.color2, glow: 6 });
                spawnBullet(muzzle.x - 14, muzzle.y, -80, -560, p.id, { r: 3, color: p.color1, glow: 6 });
                spawnBullet(muzzle.x + 14, muzzle.y, 80, -560, p.id, { r: 3, color: p.color1, glow: 6 });
            } else if (p.power === 1) {
                // double
                spawnBullet(muzzle.x - 8, muzzle.y, -20, -640, p.id, { r: 3, color: p.color2, glow: 6 });
                spawnBullet(muzzle.x + 8, muzzle.y, 20, -640, p.id, { r: 3, color: p.color2, glow: 6 });
            } else {
                spawnBullet(muzzle.x, muzzle.y, 0, -720, p.id, { r: 3, color: p.color2, glow: 8 });
            }
            // muzzle particles
            for (let i = 0; i < 6; i++) {
                spawnParticle(muzzle.x + rand(-6, 6), muzzle.y + 4, rand(-30, 30), rand(-80, -160), p.color1, 300 + Math.random() * 200);
            }
        }

        /* ---------- Enemies spawn & AI ---------- */
        function spawnEnemy(type, x, y, cfg = {}) {
            const base = { type, x, y, w: 30, h: 30, hp: 1, vx: 0, vy: 50, angle: 0, shootTimer: rand(800, 2000), score: 50, color: '#ff4' };
            if (type === 'saucer') {
                base.w = 34; base.h = 18; base.hp = 1; base.vy = 50; base.score = 60; base.color = '#ff5b9a';
            } else if (type === 'droid') {
                base.w = 30; base.h = 30; base.hp = 2; base.vy = 70; base.score = 120; base.color = '#ff9f59';
            } else if (type === 'bomber') {
                base.w = 44; base.h = 36; base.hp = 4; base.vy = 40; base.score = 300; base.color = '#d17aff';
            }
            enemies.push(Object.assign(base, cfg));
        }

        function startWave() {
            wave++;
            UI_WAVE.textContent = 'WAVE: ' + wave;
            const count = 4 + Math.floor(wave * 0.8);
            const spacing = WIDTH / (count + 1);
            for (let i = 0; i < count; i++) {
                const x = spacing * (i + 1) + rand(-spacing * 0.2, spacing * 0.2);
                const y = -rand(20, 220);
                // choose type by wave
                let type = 'saucer';
                if (wave > 4 && Math.random() < 0.25) type = 'droid';
                if (wave > 8 && Math.random() < 0.12) type = 'bomber';
                spawnEnemy(type, x, y, { vy: 60 + wave * 4, vx: Math.sin(i) * 20 });
            }
            // small chance to spawn a fast kamikaze
            if (Math.random() < 0.35 + wave * 0.02) {
                spawnEnemy('droid', rand(60, WIDTH - 60), -80, { vy: 120 + wave * 10, vx: rand(-40, 40), hp: 1, score: 80 });
            }
        }

        /* ---------- Collision helpers ---------- */
        function rectHit(a, b) {
            return !(a.x + a.w / 2 < b.x - (b.w || b.r) || a.x - a.w / 2 > b.x + (b.w || b.r) || a.y + a.h / 2 < b.y - (b.h || b.r) || a.y - a.h / 2 > b.y + (b.h || b.r));
        }

        /* ---------- Powerups ---------- */
        const POWER_TYPES = ['triple', 'shield', 'score'];
        function maybeSpawnPowerup(x, y) {
            if (Math.random() < 0.12) {
                const t = Math.random() < 0.6 ? 'triple' : (Math.random() < 0.5 ? 'shield' : 'score');
                spawnPowerup(x, y, t);
            }
        }

        /* ---------- Enemy behaviors ---------- */
        function updateEnemies(dt) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.angle += dt * 2;
                e.x += Math.sin(e.angle * 0.5) * (20 * dt);
                e.y += e.vy * dt;
                // shooting
                e.shootTimer -= dt * 1000;
                if (e.shootTimer <= 0) {
                    e.shootTimer = rand(600, 2400) - wave * 30;
                    // shoot towards random player if alive
                    const targets = players.filter(p => p.alive);
                    if (targets.length) {
                        const t = targets[Math.floor(Math.random() * targets.length)];
                        const dx = t.x - e.x;
                        const dy = t.y - e.y;
                        const mag = Math.hypot(dx, dy) || 1;
                        spawnEnemyBullet(e.x, e.y + 6, (dx / mag) * 180, (dy / mag) * 180, { color: '#ff9', glow: 10 });
                    } else {
                        // shoot downward
                        spawnEnemyBullet(e.x, e.y + 6, 0, 200, { color: '#ff9', glow: 10 });
                    }
                }
                // off-screen kill
                if (e.y > HEIGHT + 80) { enemies.splice(i, 1); continue; }
                // collision with player bullets
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const b = bullets[j];
                    if (b.owner && Math.abs(b.x - e.x) < 30 && Math.abs(b.y - e.y) < 30) {
                        // hit
                        bullets.splice(j, 1);
                        e.hp -= 1;
                        // hit particles
                        for (let k = 0; k < 8; k++) {
                            spawnParticle(b.x, b.y, rand(-120, 120), rand(-120, 120), e.color, 350 + Math.random() * 200);
                        }
                        if (e.hp <= 0) {
                            score += e.score;
                            maybeSpawnPowerup(e.x, e.y);
                            // explosion particles
                            const cols = ['#ff6b2d', '#ffedb2', '#2dd7ff', '#8bffb8', '#ff6bf0'];
                            for (let k = 0; k < 26; k++) {
                                spawnParticle(e.x, e.y, rand(-300, 300), rand(-300, 300), cols[Math.floor(Math.random() * cols.length)], 600 + Math.random() * 500);
                            }
                            enemies.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }

        /* ---------- Update Bullets ---------- */
        function updateBullets(dt) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += b.dx * dt;
                b.y += b.dy * dt;
                b.life -= dt * 1000;
                if (b.y < -20 || b.y > HEIGHT + 20 || b.life <= 0) { bullets.splice(i, 1); continue; }
                // enemy collision handled in updateEnemies
            }
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];
                b.x += b.dx * dt;
                b.y += b.dy * dt;
                b.life -= dt * 1000;
                if (b.y < -20 || b.y > HEIGHT + 20 || b.life <= 0) { enemyBullets.splice(i, 1); continue; }
                // player collision
                for (let p of players) {
                    if (!p.alive || p.shield > 0) continue;
                    const dx = Math.abs(b.x - p.x), dy = Math.abs(b.y - p.y);
                    if (dx < 18 && dy < 20) {
                        // hit
                        enemyBullets.splice(i, 1);
                        p.lives -= 1;
                        p.alive = p.lives > 0;
                        p.respawnTimer = p.alive ? 1500 : 0;
                        // particles
                        for (let k = 0; k < 18; k++) spawnParticle(p.x + rand(-10, 10), p.y + rand(-10, 10), rand(-200, 200), rand(-200, 200), '#ff6b2d', 600);
                        if (!p.alive) {
                            // if both dead -> game over handled elsewhere
                        }
                        break;
                    }
                }
            }
        }

        /* ---------- Update Powerups ---------- */
        function updatePowerups(dt) {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const pw = powerups[i];
                pw.y += pw.vy * dt;
                pw.wob += dt * 6;
                if (pw.y > HEIGHT + 20 || now() - pw.spawn > pw.ttl) { powerups.splice(i, 1); continue; }
                for (let p of players) {
                    if (!p.alive) continue;
                    if (Math.abs(p.x - pw.x) < 24 && Math.abs(p.y - pw.y) < 24) {
                        // collect
                        if (pw.type === 'triple') { p.power = Math.min(2, (p.power || 0) + 1); setTimeout(() => { p.power = Math.max(0, p.power - 1); }, 18000); }
                        if (pw.type === 'shield') { p.shield = 18000; } // 18s
                        if (pw.type === 'score') { score += 250; }
                        for (let k = 0; k < 14; k++) spawnParticle(pw.x + rand(-6, 6), pw.y + rand(-6, 6), rand(-120, 120), rand(-120, 120), '#9ff', 500);
                        powerups.splice(i, 1);
                        break;
                    }
                }
            }
        }

        /* ---------- Particles ---------- */
        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const s = particles[i];
                s.x += s.vx * dt;
                s.y += s.vy * dt;
                s.vy += 80 * dt;
                s.age += dt * 1000;
                if (s.age > s.life) particles.splice(i, 1);
            }
        }

        /* ---------- Players update ---------- */
        function updatePlayers(dt) {
            for (let p of players) {
                if (p.cooldown > 0) p.cooldown -= dt * 1000;
                if (p.shield > 0) p.shield = Math.max(0, p.shield - dt * 1000);
                if (p.respawnTimer > 0) {
                    p.respawnTimer -= dt * 1000;
                    if (p.respawnTimer <= 0) {
                        p.alive = true;
                        p.x = clamp(p.x, 40, WIDTH - 40);
                        p.y = HEIGHT - 120;
                        // short invul
                        p.shield = 2200;
                    }
                }
                if (p.alive) control(p, dt);
            }
        }

        /* ---------- Wave progression check ---------- */
        function checkWave() {
            if (enemies.length === 0 && particles.length < 10) {
                // small delay then start next wave
                setTimeout(() => { if (enemies.length === 0) startWave(); }, 600);
            }
        }

        /* ---------- Game Over / Restart ---------- */
        function isGameOver() { return players.every(p => !p.alive && p.lives <= 0); }
        function restartGame() {
            score = 0; wave = 0;
            bullets = []; enemyBullets = []; enemies = []; particles = []; powerups = [];
            for (let p of players) { p.lives = 3; p.alive = true; p.respawnTimer = 0; p.power = 0; p.shield = 0; p.x = (p.id === 1 ? WIDTH * 0.25 : WIDTH * 0.75); p.y = HEIGHT - 120; }
            CENTER.style.display = 'none';
            startWave();
        }

        /* ---------- Rendering ---------- */
        function drawShip(x, y, w, h, c1, c2, rot, glow) {
            ctx.save();
            ctx.translate(x, y);
            if (rot) ctx.rotate(rot);
            ctx.shadowBlur = glow * 6;
            ctx.shadowColor = c1;
            // body
            ctx.beginPath();
            ctx.moveTo(0, -h * 0.6);
            ctx.lineTo(w * 0.6, h * 0.4);
            ctx.lineTo(0, h * 0.15);
            ctx.lineTo(-w * 0.6, h * 0.4);
            ctx.closePath();
            const g = ctx.createLinearGradient(-w, -h, w, h);
            g.addColorStop(0, c1); g.addColorStop(0.6, c2); g.addColorStop(1, "#ffffff");
            ctx.fillStyle = g;
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.strokeStyle = "rgba(255,255,255,0.08)";
            ctx.stroke();
            // cockpit
            ctx.beginPath();
            ctx.ellipse(0, -h * 0.18, w * 0.24, h * 0.12, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.18)';
            ctx.fill();
            ctx.restore();
        }

        function render() {
            // background (clear)
            ctx.fillStyle = '#020007';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // stars parallax
            for (let i = 0; i < starsLayers.length; i++) {
                const L = starsLayers[i];
                for (let s of L.stars) {
                    const y = (s.y + (now() * 0.001) * L.speed) % (HEIGHT + 20);
                    ctx.fillStyle = L.color;
                    ctx.globalAlpha = 0.9;
                    ctx.fillRect(s.x, y, s.s * s.tw, s.s * s.tw);
                }
            }
            ctx.globalAlpha = 1;

            // nebula gradient
            const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
            g.addColorStop(0, 'rgba(40,0,60,0.08)');
            g.addColorStop(0.5, 'rgba(0,20,40,0.03)');
            g.addColorStop(1, 'rgba(0,0,0,0.06)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // enemies
            for (let e of enemies) {
                ctx.save();
                ctx.translate(e.x, e.y);
                ctx.shadowBlur = 18;
                ctx.shadowColor = e.color;
                // hull
                ctx.beginPath();
                ctx.ellipse(0, 0, e.w * 0.6, e.h * 0.55, 0, 0, Math.PI * 2);
                ctx.fillStyle = e.color;
                ctx.globalAlpha = 0.95;
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                ctx.stroke();
                // thruster glow
                ctx.fillStyle = 'rgba(255,255,255,0.02)';
                ctx.fillRect(-e.w * 0.5, e.h * 0.4, e.w, 4);
                ctx.restore();
            }

            // powerups
            for (let p of powerups) {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.shadowBlur = 12;
                if (p.type === 'triple') ctx.shadowColor = '#ffd36b';
                if (p.type === 'shield') ctx.shadowColor = '#79f1ff';
                if (p.type === 'score') ctx.shadowColor = '#b7ff9a';
                ctx.beginPath();
                ctx.arc(0, 0, 10 + Math.sin(p.wob) * 2, 0, Math.PI * 2);
                ctx.fillStyle = p.type === 'triple' ? '#ffcf6b' : (p.type === 'shield' ? '#8ff' : '#bfff9f');
                ctx.fill();
                ctx.restore();
            }

            // bullets friendly
            for (let b of bullets) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath();
                ctx.shadowBlur = b.glow * 6;
                ctx.shadowColor = b.color || '#fff';
                ctx.fillStyle = b.color || '#fff';
                ctx.ellipse(b.x, b.y, b.r, b.r * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            // enemy bullets
            for (let b of enemyBullets) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath();
                ctx.shadowBlur = b.glow * 8;
                ctx.shadowColor = b.color || '#ff9';
                ctx.fillStyle = b.color || '#ff9';
                ctx.ellipse(b.x, b.y, b.r, b.r, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // particles
            for (let s of particles) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 1 - (s.age / s.life);
                ctx.beginPath();
                ctx.shadowBlur = 6;
                ctx.shadowColor = s.color;
                ctx.fillStyle = s.color;
                ctx.ellipse(s.x, s.y, s.r, s.r, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // players
            for (let p of players) {
                if (!p.alive) {
                    // draw broken indicator
                    ctx.save();
                    ctx.globalAlpha = 0.25;
                    ctx.fillStyle = '#ff416c';
                    ctx.fillRect(p.x - 18, p.y - 12, 36, 8);
                    ctx.restore();
                    continue;
                }
                drawShip(p.x, p.y, p.w, p.h, p.color1, p.color2, 0, 6);

                // shield overlay
                if (p.shield > 0) {
                    ctx.save();
                    const a = (Math.sin(now() * 0.01) + 1) / 2 * 0.6 + 0.2;
                    ctx.globalAlpha = a;
                    ctx.beginPath();
                    ctx.shadowBlur = 28;
                    ctx.shadowColor = '#7ef';
                    ctx.strokeStyle = 'rgba(120,255,255,0.45)';
                    ctx.lineWidth = 4;
                    ctx.ellipse(p.x, p.y - 4, 26, 26, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // HUD: score already updated outside
        }

        /* ---------- Main Loop ---------- */
        function loop() {
            const t = now();
            let dt = (t - lastTime) / 1000;
            if (dt > 0.05) dt = 0.05;
            lastTime = t;

            // Update
            updatePlayers(dt);
            updateEnemies(dt);
            updateBullets(dt);
            updateParticles(dt);
            updatePowerups(dt);

            // spawn occasional enemy bullets from chance for more pressure
            if (Math.random() < dt * 0.8 && enemies.length && Math.random() < 0.02) {
                const e = enemies[Math.floor(Math.random() * enemies.length)];
                spawnEnemyBullet(e.x + rand(-6, 6), e.y + 8, rand(-40, 40), 160 + Math.random() * 60, { color: '#ffb' });
            }

            // check player bullet hits vs enemies (enemies handle being hit in updateEnemies)
            // check enemies collide with players
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                for (let p of players) {
                    if (!p.alive || p.shield > 0) continue;
                    if (Math.abs(e.x - p.x) < 28 && Math.abs(e.y - p.y) < 28) {
                        // collision: both take damage
                        // enemy dies
                        for (let k = 0; k < 18; k++) spawnParticle(e.x, e.y, rand(-220, 220), rand(-220, 220), e.color, 500);
                        score += e.score;
                        enemies.splice(i, 1);
                        // player takes hit
                        p.lives -= 1;
                        p.alive = p.lives > 0;
                        p.respawnTimer = p.alive ? 1400 : 0;
                        for (let k = 0; k < 12; k++) spawnParticle(p.x, p.y, rand(-160, 160), rand(-160, 160), '#ff6b2d', 400);
                        break;
                    }
                }
            }

            // UI updates
            UI_SCORE.textContent = 'SCORE: ' + Math.floor(score);
            UI_WAVE.textContent = 'WAVE: ' + wave;

            // Lives display
            UI_LIVES.innerHTML = '';
            for (let p of players) {
                const div = document.createElement('div');
                div.style.display = 'flex'; div.style.alignItems = 'center'; div.style.gap = '6px';
                const color = p.id === 1 ? '#ff6b2d' : '#2dd7ff';
                const name = document.createElement('div');
                name.textContent = 'P' + p.id; name.style.fontSize = '13px'; name.style.color = color; name.style.fontWeight = 700;
                div.appendChild(name);
                for (let i = 0; i < p.lives; i++) {
                    const life = document.createElement('div');
                    life.style.width = '14px'; life.style.height = '10px'; life.style.borderRadius = '3px';
                    life.style.boxShadow = '0 0 8px ' + color; life.style.background = color; div.appendChild(life);
                }
                if (!p.alive) { const dead = document.createElement('div'); dead.textContent = '✕'; dead.style.color = '#ff6b2d'; dead.style.marginLeft = '6px'; div.appendChild(dead); }
                UI_LIVES.appendChild(div);
            }

            // render
            render();

            // check next wave
            checkWave();

            // Game Over check
            if (isGameOver()) {
                running = false;
                CENTER.style.display = 'block';
                CENTER.innerHTML = `<div style="font-size:20px;color:#ffd3f5">GAME OVER</div>
                        <div style="margin-top:8px;font-size:13px;color:#9fe8ff">Score: ${Math.floor(score)}</div>
                        <div style="margin-top:10px;font-size:12px;color:#cfcfcf">Appuyez sur R pour recommencer</div>`;
            }

            requestAnimationFrame(loop);
        }

        /* ---------- Init ---------- */
        function init() {
            // set colours on players
            players[0].color1 = '#ff6b2d'; players[0].color2 = '#ffedb2';
            players[1].color1 = '#2dd7ff'; players[1].color2 = '#bff7ff';

            // initial wave after little intro
            CENTER.style.display = 'block';
            CENTER.innerHTML = `<div style="font-size:18px;color:#9fe8ff">NEON CO-OP SHMUP</div>
    <div style="margin-top:8px;color:#ffd6f0">P1: ZQSD + Space</div><div style="color:#bfeeff">P2: Arrows + Enter</div>
    <div style="margin-top:10px;color:#cfcfcf;font-size:12px">Appuyez sur une touche pour commencer...</div>`;
            // wait for any key
            function startOnKey(e) {
                window.removeEventListener('keydown', startOnKey);
                CENTER.style.display = 'none';
                startWave();
                lastTime = now();
                requestAnimationFrame(loop);
            }
            window.addEventListener('keydown', startOnKey);

            // restart handler
            window.addEventListener('keydown', (e) => {
                if (e.code === 'KeyR') {
                    restartGame();
                    running = true;
                    lastTime = now();
                    if (!running) { running = true; requestAnimationFrame(loop); }
                }
            });
        }

        init();

        /* ---------- Basic touch/resize support ---------- */
        window.addEventListener('resize', () => {
            // keep canvas size fixed to initial constraints for stable gameplay
        });

        /* ---------- Misc: slight ambient particle spawn ---------- */
        setInterval(() => {
            // small drift particles to add atmosphere
            spawnParticle(rand(0, WIDTH), -10, rand(-10, 10), rand(20, 80), Math.random() < 0.5 ? '#2dd7ff' : '#ff6b2d', 3000);
        }, 350);

        /* ---------- End of script ---------- */
    </script>
</body>

</html>