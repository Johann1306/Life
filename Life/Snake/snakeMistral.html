<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake 1v1 - Cyberpunk Neon</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0a0a1a;
            font-family: 'Arial', sans-serif;
            color: #fff;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 600px;
            height: 600px;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 20px #ff00ff, 0 0 40px #00ffff;
            background-color: #111;
            background-image:
                linear-gradient(rgba(255, 0, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #game-canvas {
            display: block;
        }

        #score {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            text-shadow: 0 0 10px #ff00ff;
        }

        #restart {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            color: #ff00ff;
            text-shadow: 0 0 15px #00ffff;
            display: none;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="game-canvas" width="600" height="600"></canvas>
        <div id="score">Vert: 0 - Bleu: 0</div>
        <div id="restart">Appuyez sur ESPACE pour recommencer</div>
    </div>

    <script>
        // --- Constants ---
        const GRID_SIZE = 20;
        const TILE_COUNT = 30;
        const GAME_SPEED = 100; // ms per frame
        const COLORS = {
            green: { head: '#00ff88', body: '#00cc66', glow: '#00ff8888' },
            blue: { head: '#0088ff', body: '#0066cc', glow: '#0088ffff' },
            apple: '#ff3333',
            grid: '#222',
            bg: '#111'
        };

        // --- Game State ---
        let game = {
            players: [
                { id: 0, color: 'green', keys: ['KeyW', 'KeyA', 'KeyS', 'KeyD'], dir: { x: 1, y: 0 }, nextDir: { x: 1, y: 0 }, body: [], score: 0 },
                { id: 1, color: 'blue', keys: ['ArrowUp', 'ArrowLeft', 'ArrowDown', 'ArrowRight'], dir: { x: -1, y: 0 }, nextDir: { x: -1, y: 0 }, body: [], score: 0 }
            ],
            apple: { x: 0, y: 0 },
            gameOver: false,
            lastTime: 0,
            gameLoopId: null
        };

        // --- DOM Elements ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const restartEl = document.getElementById('restart');

        // --- Game Initialization ---
        function initGame() {
            // Reset players
            game.players[0].body = [{ x: 5, y: 10 }, { x: 4, y: 10 }, { x: 3, y: 10 }];
            game.players[0].dir = { x: 1, y: 0 };
            game.players[0].nextDir = { x: 1, y: 0 };
            game.players[0].score = 0;

            game.players[1].body = [{ x: 25, y: 10 }, { x: 26, y: 10 }, { x: 27, y: 10 }];
            game.players[1].dir = { x: -1, y: 0 };
            game.players[1].nextDir = { x: -1, y: 0 };
            game.players[1].score = 0;

            // Place apple
            placeApple();
            game.gameOver = false;
            restartEl.style.display = 'none';
            updateScore();
        }

        // --- Apple Logic ---
        function placeApple() {
            let valid = false;
            while (!valid) {
                game.apple.x = Math.floor(Math.random() * TILE_COUNT);
                game.apple.y = Math.floor(Math.random() * TILE_COUNT);
                valid = true;
                // Check if apple is on a snake
                for (const player of game.players) {
                    for (const segment of player.body) {
                        if (segment.x === game.apple.x && segment.y === game.apple.y) {
                            valid = false;
                            break;
                        }
                    }
                    if (!valid) break;
                }
            }
        }

        // --- Collision Detection ---
        function checkCollision(player) {
            const head = player.body[0];
            // Wall collision
            if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
                return true;
            }
            // Self collision
            for (let i = 1; i < player.body.length; i++) {
                if (head.x === player.body[i].x && head.y === player.body[i].y) {
                    return true;
                }
            }
            // Other player collision
            for (const other of game.players) {
                if (other.id !== player.id) {
                    for (const segment of other.body) {
                        if (head.x === segment.x && head.y === segment.y) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // --- Apple Eating ---
        function checkAppleEaten(player) {
            const head = player.body[0];
            if (head.x === game.apple.x && head.y === game.apple.y) {
                player.score++;
                placeApple();
                return true;
            }
            return false;
        }

        // --- Game Update ---
        function updateGame(timestamp) {
            if (game.gameOver) return;

            const deltaTime = timestamp - game.lastTime;
            if (deltaTime < GAME_SPEED) {
                game.gameLoopId = requestAnimationFrame(updateGame);
                return;
            }
            game.lastTime = timestamp;

            // Update each player
            for (const player of game.players) {
                player.dir = { ...player.nextDir };
                const head = { ...player.body[0] };
                head.x += player.dir.x;
                head.y += player.dir.y;
                player.body.unshift(head);

                if (checkCollision(player)) {
                    game.gameOver = true;
                    restartEl.style.display = 'block';
                    return;
                }

                if (!checkAppleEaten(player)) {
                    player.body.pop();
                }
            }

            drawGame();
            game.gameLoopId = requestAnimationFrame(updateGame);
        }

        // --- Game Drawing ---
        function drawGame() {
            // Clear canvas
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = COLORS.grid;
            ctx.lineWidth = 0.5;
            for (let i = 0; i < TILE_COUNT; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID_SIZE, 0);
                ctx.lineTo(i * GRID_SIZE, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * GRID_SIZE);
                ctx.lineTo(canvas.width, i * GRID_SIZE);
                ctx.stroke();
            }

            // Draw apple
            ctx.fillStyle = COLORS.apple;
            ctx.beginPath();
            const appleCenterX = game.apple.x * GRID_SIZE + GRID_SIZE / 2;
            const appleCenterY = game.apple.y * GRID_SIZE + GRID_SIZE / 2;
            ctx.arc(appleCenterX, appleCenterY, GRID_SIZE / 2 - 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 10;
            ctx.shadowColor = COLORS.apple;
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw snakes
            for (const player of game.players) {
                const color = COLORS[player.color];
                // Draw body
                for (let i = 1; i < player.body.length; i++) {
                    const segment = player.body[i];
                    ctx.fillStyle = color.body;
                    ctx.fillRect(segment.x * GRID_SIZE + 1, segment.y * GRID_SIZE + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = color.glow;
                    ctx.fillRect(segment.x * GRID_SIZE + 1, segment.y * GRID_SIZE + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                    ctx.shadowBlur = 0;
                }
                // Draw head
                const head = player.body[0];
                ctx.fillStyle = color.head;
                ctx.fillRect(head.x * GRID_SIZE + 1, head.y * GRID_SIZE + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                ctx.shadowBlur = 10;
                ctx.shadowColor = color.glow;
                ctx.fillRect(head.x * GRID_SIZE + 1, head.y * GRID_SIZE + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                ctx.shadowBlur = 0;
            }
        }

        // --- Input Handling ---
        function handleKeyDown(e) {
            // Restart game
            if (e.code === 'Space' && game.gameOver) {
                initGame();
                game.gameLoopId = requestAnimationFrame(updateGame);
                return;
            }

            // Player 1 (ZQSD)
            if (e.code === 'KeyW' && game.players[0].dir.y === 0) {
                game.players[0].nextDir = { x: 0, y: -1 };
            } else if (e.code === 'KeyA' && game.players[0].dir.x === 0) {
                game.players[0].nextDir = { x: -1, y: 0 };
            } else if (e.code === 'KeyS' && game.players[0].dir.y === 0) {
                game.players[0].nextDir = { x: 0, y: 1 };
            } else if (e.code === 'KeyD' && game.players[0].dir.x === 0) {
                game.players[0].nextDir = { x: 1, y: 0 };
            }

            // Player 2 (Arrow Keys)
            if (e.code === 'ArrowUp' && game.players[1].dir.y === 0) {
                game.players[1].nextDir = { x: 0, y: -1 };
            } else if (e.code === 'ArrowLeft' && game.players[1].dir.x === 0) {
                game.players[1].nextDir = { x: -1, y: 0 };
            } else if (e.code === 'ArrowDown' && game.players[1].dir.y === 0) {
                game.players[1].nextDir = { x: 0, y: 1 };
            } else if (e.code === 'ArrowRight' && game.players[1].dir.x === 0) {
                game.players[1].nextDir = { x: 1, y: 0 };
            }
        }

        // --- Score Update ---
        function updateScore() {
            scoreEl.textContent = `Vert: ${game.players[0].score} - Bleu: ${game.players[1].score}`;
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', handleKeyDown);

        // --- Start Game ---
        initGame();
        game.gameLoopId = requestAnimationFrame(updateGame);
    </script>
</body>